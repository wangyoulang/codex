## 为什么codex这么稳，真实复杂的工程也能完成的很好？

其原因虽然很模型强大有一定关系，但主要还是因为codex-core把模型放进了一个可行动、可观测、可迭代的任务里。模型->调工具->拿反馈->再调模型->直到收敛。

### 1、模型怎么调工具

数据结构：

- schema：**工具定义的参数约束**（通常是 JSON Schema；会随工具一起发给模型，让模型知道“工具名/参数形状”）。
- ToolRouter：**工具路由器**：把“可用工具列表（spec）”提供给模型，同时把模型输出里的 tool call 解析成内部 `ToolCall`，再分发执行（`codex-rs/core/src/tools/router.rs`）。
- ToolSpec：**单个工具的“声明/规格”**（工具名、描述、参数 schema，或 freeform 工具的 grammar），用于发给模型（`codex-rs/core/src/client_common.rs` 的 `tools::ToolSpec`）。
- ToolHandler：**工具执行器（trait）**：真正解析 payload、执行工具、产出 `ToolOutput`（`codex-rs/core/src/tools/registry.rs` 的 `ToolHandler`）。
- ToolCall：**内部统一的工具调用表示**（`tool_name/call_id/payload`），由 `ToolRouter::build_tool_call` 从模型输出项构建（`codex-rs/core/src/tools/router.rs:59`）。
- ResponseItem::FunctionCall / CustomToolCall / LocalShellCall：**模型在协议层发起“工具调用”的三种输出项形态**：
  - `FunctionCall`：标准 function tool 调用（参数是 JSON 字符串）。
  - `CustomToolCall`：自定义/自由格式（freeform）工具调用（如 freeform `apply_patch`）。
  - `LocalShellCall`：协议里“本地 shell 调用”的一种形态（Codex 会统一解析成内部 `ToolCall`）。
  这些分支都在 `ToolRouter::build_tool_call` 里被统一解析（`codex-rs/core/src/tools/router.rs:59`）。
- ToolRegistry::dispatch：**分发执行入口**：根据 `tool_name` 找到对应 `ToolHandler` 执行，并把成功/失败统一包装成“写回模型的工具输出”（`codex-rs/core/src/tools/registry.rs:61`）。
- ResponseInputItem：**写回模型的“输入项”类型**，用于把工具输出（以及其它输入）加入下一轮 prompt（`codex_protocol::models::ResponseInputItem`）。
- 对话历史：**会话历史记录**（内存历史 + rollout 持久化）。工具调用与工具输出都会通过 `record_conversation_items` 写入历史，从而进入下一轮 `turn_input`（`codex-rs/core/src/codex.rs:1168`）。

更准确地说：模型在输出里发起 tool call → `ToolRouter/ToolRegistry` 找到对应 `ToolHandler` 执行 → 产出 `ResponseInputItem`（工具输出）写回对话历史 → 下一轮 `turn_input` 会包含这份真实输出。



### 2、codex-cli怎么收敛的

算法：

- run_task：**任务循环（跨多个 turn）**。只要本轮出现过工具调用（`needs_follow_up=true`），就继续下一轮（`codex-rs/core/src/codex.rs:2207`）。
- turn_input：**本轮发给模型的输入**：由“当前历史（已包含工具输出）+ pending_input”等组成，是“上下文”的主要载体（构造逻辑在 `codex-rs/core/src/codex.rs` 的 `run_task` 内）。
- run_turn：**跑一轮模型请求**：收集（含 MCP）工具 → 构建 `ToolRouter` → 组装 `Prompt` → 调 `try_run_turn` 消费模型流（`codex-rs/core/src/codex.rs:2367`）。
- try_run_turn：**真正消费模型流式响应的循环**：处理 `ResponseEvent`，遇到 `OutputItemDone` 调 `handle_output_item_done`；同时维护 `in_flight` 工具 futures，并在 turn 末尾排干（`codex-rs/core/src/codex.rs:2506`）。
- handle_output_item_done：**处理一个“已完成输出项”**：用 `ToolRouter::build_tool_call` 判断是否为 tool call；若是则入历史并启动工具 future；否则当普通消息/推理入历史（`codex-rs/core/src/stream_events_utils.rs:43`）。
  - tool call：记录历史，继续迭代
  - 不是tool_call：收敛，消息记入历史。
- needs_follow_up：**迭代开关**：本 turn 是否还需要下一轮模型（一般：本轮发生过工具调用就为 true；否则认为任务收敛）（`codex-rs/core/src/codex.rs:2313`）。
- 并发：**工具并发/串行控制**：哪些工具允许并行由工具注册时标记；运行时用读写锁实现——支持并行的工具拿读锁并行，否则拿写锁串行（`codex-rs/core/src/tools/parallel.rs`）。

### 3、为什么能这么稳

- shell/exec_command：能跑编译、测试、脚本，输出可以确认是否真的闭环。
- ToolOrchestrator：**工具编排器**：统一做“是否需要审批（approval）→ 选择沙箱（sandbox）→ 执行 →（策略允许时）失败后无沙箱重试”等流程（`codex-rs/core/src/tools/orchestrator.rs`）。

- sandbox：**命令隔离策略**（如 ReadOnly/WorkspaceWrite/DangerFullAccess/ExternalSandbox）。具体平台隔离由 `SandboxManager` 选择并把命令 transform 成可执行环境（`codex-rs/core/src/sandboxing/mod.rs`）。
- ToolRegistry：**工具注册表/分发器**：持有 `tool_name -> ToolHandler` 映射，并统一处理 mutating 门禁、错误包装等（`codex-rs/core/src/tools/registry.rs`）。
- mutating 工具：**可能修改文件/环境的工具调用**。由 `ToolHandler::is_mutating` 判定；对 mutating 工具，Codex 会在执行前等待 `tool_call_gate` 放行（`codex-rs/core/src/tools/registry.rs:115`）。
- wait_ready：**等待放行**：对 mutating 工具调用 `tool_call_gate.wait_ready()`，避免在某些后台准备工作完成前就改写仓库（`codex-rs/core/src/tools/registry.rs:115`）。
- GhostSnapshotTask：**后台仓库快照任务**：创建 ghost commit（用于 undo/安全），完成后 `mark_ready` 放行 mutating 工具（`codex-rs/core/src/tasks/ghost_snapshot.rs`）。

### 4、一个例子

- run_task
- TaskStarted
- Turn
- run_turn：一次 turn 的调度入口：构造工具路由与 prompt，并进入 `try_run_turn` 消费流（`codex-rs/core/src/codex.rs:2367`）。
- ToolRouter：工具路由器：提供 tools spec + 解析 tool call + 分发（`codex-rs/core/src/tools/router.rs`）。
- router.specs()：返回“发给模型的工具声明列表（ToolSpec）”，包含内置工具与 MCP 工具（`codex-rs/core/src/tools/router.rs`）。
- Prompt：一次模型请求的 payload（input、tools、parallel_tool_calls、instructions override 等）（`codex-rs/core/src/client_common.rs`）。
- ToolsConfig：本轮工具配置：决定 shell 类型、apply_patch 类型、是否启用 web_search/view_image、实验工具列表等（`codex-rs/core/src/tools/spec.rs:34`）。
- build_specs：根据 `ToolsConfig` 构建工具 spec + 注册 handler，并合并 MCP tools（`codex-rs/core/src/tools/spec.rs:979`）。
- spec + handler：spec 是“发给模型看的工具说明/约束”；handler 是“本地执行实现”。
- ToolRouter::from_config：用 `ToolsConfig`（和可选 MCP tools）创建 `ToolRouter`（`codex-rs/core/src/tools/router.rs:34`）。
- router：`ToolRouter` 实例（内部包含 `specs` + `ToolRegistry`）。
- handle_output_item_done：处理一个完成的输出项：识别 tool call 并排队执行，否则当普通消息入历史（`codex-rs/core/src/stream_events_utils.rs:43`）。
- stream_events_utils：处理“模型输出项 → 入历史 →（若需要）调工具”的辅助模块（`codex-rs/core/src/stream_events_utils.rs`）。
- ToolRouter::build_tool_call：从 `ResponseItem` 解析内部 `ToolCall`（`codex-rs/core/src/tools/router.rs:59`）。
- tool call：模型发起的“请求执行某个工具”的输出项（FunctionCall/CustomToolCall/LocalShellCall 等）。
- future：工具执行的异步任务；执行完会产出“写回模型的工具输出”（`ResponseInputItem`）。
- in_flight：本 turn 内正在执行/待完成的工具 futures 队列（`codex-rs/core/src/codex.rs` 里用 `FuturesOrdered` 管理，并在 turn 末尾 `drain_in_flight` 排干）。
- needs_follow_up=true：本 turn 出现过工具调用，必须继续下一轮，让模型读到工具输出再决策。
- ToolCallRuntime::handle_tool_call：启动工具执行，并按工具是否支持并行选择读锁/写锁（`codex-rs/core/src/tools/parallel.rs:49`）。
- ToolRouter::dispatch_tool_call：把 `ToolCall` 交给 `ToolRegistry` 执行，并把错误包装成失败的 tool output（`codex-rs/core/src/tools/router.rs:130`）。
- ToolRegistry::dispatch：根据 `tool_name` 找 `ToolHandler` 并执行（`codex-rs/core/src/tools/registry.rs:61`）。
- mutating：是否“可能修改文件/环境”的工具调用；由 handler 的 `is_mutating` 判定。
- wait_ready：mutating 工具执行前等待 `tool_call_gate` 放行（`codex-rs/core/src/tools/registry.rs:115`）。
- Ghost Snapshot：ghost commit 快照（用于 undo/安全）；由 `GhostSnapshotTask` 在后台生成。
- handler：具体工具的执行实现（`ToolHandler`）。
- ToolOrchestrator::run：统一工具执行流程（审批/沙箱选择/执行/必要时重试）（`codex-rs/core/src/tools/orchestrator.rs:34`）。
- sandbox：命令隔离策略与平台沙箱包装（见第 3 节的 sandbox 解释）。
- shell：工具：执行命令并返回输出（可能对应 `shell`/`shell_command`/`exec_command` 等实现）。
- ExecCommandBegin/End：事件：命令开始/结束（`codex-rs/core/src/tools/events.rs`）。
- apply_patch：工具：按补丁 grammar 修改文件（`codex-rs/core/src/tools/handlers/apply_patch.rs`）。
- maybe_parse_apply_patch_verified：解析并校验补丁输入（grammar/正确性）；在 `ApplyPatchHandler` 中调用（`codex-rs/core/src/tools/handlers/apply_patch.rs`）。
- PatchApplyBegin/End：事件：补丁开始/结束（`codex-rs/core/src/tools/events.rs`）。
- in-flight：同 `in_flight`：指本轮还未完成的工具执行任务。
- 历史和上下文：历史是已记录的 `ResponseItem`；上下文是喂给模型的“历史子集”（可能被截断/compact）。
- freeform apply_patch：`apply_patch` 以 freeform grammar 工具形式提供；启用时，Codex 会把 shell 输出重序列化成稳定的纯文本格式供模型阅读（`codex-rs/core/src/client_common.rs:71`）。
- approval_policy=never：审批策略为 Never：默认执行审批会 Skip，不向用户请求批准（`codex-rs/core/src/tools/sandboxing.rs:129`）。
- sandbox=danger-full-access：沙箱策略为 DangerFullAccess：通常不启用平台隔离，命令直接执行（`codex-rs/core/src/sandboxing/mod.rs:63`）。

## 沙箱是什么？

首先沙箱是针对当前现成的，现成从配置或者命令行参数中读取当前会话的沙箱配置：
- 沙箱模式：只读、工作目录写、完全支配
- 网络是否允许
- 工作目录是谁，默认是当前目录。可通过--add-dir配置

具体怎么用？
用户发送了一条命令，安全策略决定它能不能执行。如果可以，进到沙箱去执行，沙箱会锁在安全边界内去执行。

举个例子，我让codex跑一个rm -rf build。
- 安全策略分析该命令是否有危险，如果没有危险就进入下一步
- codex根据配置和参数计算权限边界：哪些行为允许，哪些不允许
- 启动一个专门负责沙箱的“Linux 沙箱进程”
  - 构建并应用 Landlock 规则，把项目工作目录及其他明确允许写的路径，标为“可写”。
  - 装 seccomp 过滤器，如有必要，在“系统调用层”把网络能力关掉
  - 在沙箱中执行rm -rf build命令