# 沙箱机制

<cite>
**本文档中引用的文件**  
- [mod.rs](file://codex-rs\core\src\sandboxing\mod.rs)
- [landlock.rs](file://codex-rs\core\src\landlock.rs)
- [seatbelt.rs](file://codex-rs\core\src\seatbelt.rs)
- [seatbelt_base_policy.sbpl](file://codex-rs\core\src\seatbelt_base_policy.sbpl)
- [seatbelt_network_policy.sbpl](file://codex-rs\core\src\seatbelt_network_policy.sbpl)
- [lib.rs](file://codex-rs\windows-sandbox-rs\src\lib.rs)
- [policy.rs](file://codex-rs\windows-sandbox-rs\src\policy.rs)
- [debug_sandbox.rs](file://codex-rs\cli\src\debug_sandbox.rs)
- [sandbox.md](file://docs\sandbox.md)
</cite>

## 目录
1. [引言](#引言)
2. [沙箱设计哲学与工作流位置](#沙箱设计哲学与工作流位置)
3. [Linux平台沙箱机制](#linux平台沙箱机制)
4. [Windows平台沙箱机制](#windows平台沙箱机制)
5. [macOS平台沙箱机制](#macos平台沙箱机制)
6. [配置示例与故障排除](#配置示例与故障排除)
7. [`codex sandbox`命令行工具](#codex-sandbox命令行工具)
8. [沙箱局限性](#沙箱局限性)
9. [结论](#结论)

## 引言

Codex的沙箱机制是其多层安全架构的核心组件，旨在隔离和限制AI生成代码的执行，防止潜在的恶意操作对系统造成损害。该机制通过在不同操作系统平台上利用原生安全特性，为AI执行环境创建一个受控的、权限受限的运行空间。沙箱不仅限制了文件系统的访问，还控制了网络连接和其他系统资源的使用，确保AI操作在预定义的安全边界内进行。

**Section sources**
- [sandbox.md](file://docs\sandbox.md#L3-L28)

## 沙箱设计哲学与工作流位置

Codex的沙箱设计哲学基于“最小权限原则”，即AI代理仅被授予完成其任务所必需的最低权限。沙箱在Codex工作流中扮演着执行环境的守门人角色。当AI生成一个需要执行的命令时，该命令不会直接在用户的主环境中运行，而是首先被提交给沙箱管理器。沙箱管理器根据当前的配置和策略，决定是否以及如何在沙箱环境中执行该命令。

沙箱策略（`SandboxPolicy`）是这一过程的核心，它定义了三种主要模式：只读（`ReadOnly`）、工作区写入（`WorkspaceWrite`）和危险全访问（`DangerFullAccess`）。这些策略决定了AI可以读写哪些文件路径以及是否允许网络访问。沙箱管理器（`SandboxManager`）负责根据这些策略，将原始的命令规范（`CommandSpec`）转换为一个准备执行的环境（`ExecEnv`），这个过程包括了对命令行参数的修改、环境变量的设置以及调用平台特定的沙箱工具。

**Section sources**
- [mod.rs](file://codex-rs\core\src\sandboxing\mod.rs#L29-L181)
- [config_requirements.rs](file://codex-rs\core\src\config_loader\config_requirements.rs#L116-L153)

## Linux平台沙箱机制

在Linux平台上，Codex利用Landlock LSM（Linux Security Module）来创建无特权的文件系统访问控制。Landlock允许非特权进程在不依赖root权限的情况下，为自己或其子进程设置强制性的访问控制规则。

### 技术细节

沙箱的实现依赖于一个名为`codex-linux-sandbox`的独立可执行文件。当需要在沙箱中执行命令时，Codex会将原始命令作为参数传递给这个可执行文件。`codex-linux-sandbox`内部使用Landlock API来加载BPF（Berkeley Packet Filter）程序，并构建规则集。

具体流程如下：
1.  **策略序列化**：Codex将内部的`SandboxPolicy`对象序列化为JSON格式。
2.  **参数构建**：调用`create_linux_sandbox_command_args`函数，该函数会生成一个包含`--sandbox-policy-cwd`、`--sandbox-policy`等参数的命令行列表。`--sandbox-policy`参数的值就是上一步生成的JSON字符串。
3.  **命令执行**：最终的执行命令变为`[codex-linux-sandbox] --sandbox-policy-cwd [cwd] --sandbox-policy [json_policy] -- [original_command]`。`--`分隔符确保后续的原始命令参数不会被`codex-linux-sandbox`误解析为自己的选项。

`codex-linux-sandbox`可执行文件本身负责解析这些参数，然后使用Landlock API应用相应的文件系统访问规则。例如，对于`WorkspaceWrite`策略，它会允许对工作区目录及其子目录的写入，但会阻止对`.git`和`.codex`等敏感子目录的写入，以防止恶意代码注入。

**Section sources**
- [landlock.rs](file://codex-rs\core\src\landlock.rs#L9-L73)
- [mod.rs](file://codex-rs\core\src\sandboxing\mod.rs#L131-L144)
- [linux-sandbox/README.md](file://codex-rs\linux-sandbox\README.md#L1-L9)

## Windows平台沙箱机制

在Windows平台上，Codex采用了一种基于令牌限制（Token Restriction）和访问控制列表（ACL）的沙箱机制。该机制通过`windows-sandbox-rs` crate实现，旨在创建一个受限的用户环境来执行AI命令。

### 技术细节

1.  **受限令牌**：沙箱的核心是创建一个“受限令牌”（Restricted Token）。这个令牌是从一个名为“AppContainer”的特殊用户账户派生出来的。AppContainer本身具有非常有限的权限。
2.  **能力SID**：为了授予特定权限，Codex使用“能力SID”（Capability SIDs）。这些是特殊的标识符，可以附加到受限令牌上，以精确地授予对特定文件夹的读写权限。例如，`create_workspace_write_token_with_cap_from`函数会创建一个令牌，并附加一个允许写入工作区目录的能力SID。
3.  **进程提权**：`codex-windows-sandbox` crate提供了`run_windows_sandbox_capture`函数，该函数使用`CreateProcessAsUserW` Windows API，以受限令牌的身份启动目标进程。这确保了新进程从一开始就运行在受限的环境中。
4.  **网络限制**：网络访问的限制是通过覆盖环境变量（如`HTTP_PROXY`）和插入占位符可执行文件来实现的，从而阻止常见的网络工具（如`curl`、`wget`）进行出站连接。

**Section sources**
- [lib.rs](file://codex-rs\windows-sandbox-rs\src\lib.rs#L77-L427)
- [policy.rs](file://codex-rs\windows-sandbox-rs\src\policy.rs#L39-L57)
- [identity.rs](file://codex-rs\windows-sandbox-rs\src\identity.rs#L92-L126)

## macOS平台沙箱机制

在macOS平台上，Codex利用系统内置的`seatbelt`框架来实现沙箱。`seatbelt`是一个强大的强制访问控制（MAC）系统，允许通过声明式策略文件来精确控制进程的权限。

### 技术细节

1.  **策略文件**：Codex使用两个核心的策略文件：`seatbelt_base_policy.sbpl`和`seatbelt_network_policy.sbpl`。`seatbelt_base_policy.sbpl`定义了基础的、安全的默认规则，例如允许进程创建、读取系统信息，但默认拒绝所有其他操作（`deny default`）。`seatbelt_network_policy.sbpl`则包含了允许网络出站和入站的规则。
2.  **策略构建**：`create_seatbelt_command_args`函数负责动态构建最终的`seatbelt`策略。它会根据当前的`SandboxPolicy`，将基础策略与文件读写规则和网络规则（如果允许）进行组合。
3.  **文件系统规则**：
    *   **读取**：如果策略允许完全磁盘读取，则添加`(allow file-read*)`规则。
    *   **写入**：对于`WorkspaceWrite`模式，它会为每个可写根目录生成一个`file-write*`规则。特别地，它会检查这些根目录下是否存在`.git`或`.codex`目录，并使用`(require-not (subpath ...))`子句来明确禁止对这些敏感子目录的写入。
4.  **参数化执行**：最终的命令通过`/usr/bin/sandbox-exec`执行，并使用`-D`参数将可写目录的路径传递给策略文件中的占位符（如`WRITABLE_ROOT_0`）。完整的命令行类似于`sandbox-exec -p [combined_policy] -DWRITABLE_ROOT_0=[path] -- [original_command]`。

**Section sources**
- [seatbelt.rs](file://codex-rs\core\src\seatbelt.rs#L1-L532)
- [seatbelt_base_policy.sbpl](file://codex-rs\core\src\seatbelt_base_policy.sbpl#L1-L108)
- [seatbelt_network_policy.sbpl](file://codex-rs\core\src\seatbelt_network_policy.sbpl#L1-L31)

## 配置示例与故障排除

### 配置示例

在`config.toml`中，可以通过以下方式配置沙箱模式：
```toml
# 启用工作区写入模式
sandbox_mode = "workspace-write"

# 在工作区写入模式下允许网络访问
[sandbox_workspace_write]
network_access = true
```

### 故障排除

最常见的问题是权限错误，例如“Operation not permitted”。这通常意味着沙箱策略阻止了某个操作。
*   **检查策略**：确认当前的`sandbox_mode`设置是否符合预期。
*   **检查路径**：确保命令试图访问的文件或目录在沙箱策略允许的范围内。特别是，检查是否试图写入`.git`或`.codex`目录。
*   **使用调试工具**：利用`codex sandbox`命令来测试和验证配置。

**Section sources**
- [sandbox.md](file://docs\sandbox.md#L29-L55)

## `codex sandbox`命令行工具

`codex sandbox`命令行工具是测试和验证沙箱配置的强大助手。它允许用户在不启动完整Codex会话的情况下，直接在沙箱环境中执行任意命令。

### 使用方法

```bash
# 在macOS上测试命令
codex sandbox macos [--full-auto] [COMMAND]...

# 在Linux上测试命令
codex sandbox linux [--full-auto] [COMMAND]...

# 旧版别名
codex debug seatbelt [--full-auto] [COMMAND]...
codex debug landlock [--full-auto] [COMMAND]...
```

`--full-auto`标志会使用`workspace-write`沙箱模式，否则默认使用`read-only`模式。这对于快速验证某个命令在沙箱中的行为非常有用。

**Section sources**
- [debug_sandbox.rs](file://codex-rs\cli\src\debug_sandbox.rs#L1-L277)
- [sandbox.md](file://docs\sandbox.md#L82-L97)

## 沙箱局限性

尽管Codex的沙箱机制在各平台上都提供了强大的安全保障，但仍存在一些局限性：
*   **Windows平台**：主要局限在于无法阻止对“世界可写”（world-writable）目录的写入。如果一个目录的Everyone组具有写权限，沙箱无法覆盖此权限。
*   **容器化环境**：在Docker等容器化Linux环境中，如果宿主机或容器配置未暴露Landlock/seccomp功能，沙箱可能无法正常工作。
*   **资源耗尽**：沙箱主要关注权限控制，对CPU、内存等资源的消耗限制有限。
*   **侧信道攻击**：理论上存在通过时间侧信道等高级攻击绕过沙箱的可能性，尽管这在实践中较为困难。

**Section sources**
- [sandbox.md](file://docs\sandbox.md#L79-L80)

## 结论

Codex的沙箱机制通过在Linux、Windows和macOS三个主要平台上利用各自原生的安全框架，构建了一个强大而灵活的多层安全架构。它成功地将AI生成代码的执行隔离在一个受控环境中，极大地降低了潜在的安全风险。通过`SandboxPolicy`的精细控制和`codex sandbox`工具的便捷验证，用户可以有效地管理和测试其安全策略。尽管存在一些平台特定的局限性，但该机制为AI辅助编程提供了一个坚实的安全基础。