# 策略语法

<cite>
**本文档中引用的文件**  
- [lib.rs](file://codex-rs\execpolicy\src\lib.rs)
- [rule.rs](file://codex-rs\execpolicy\src\rule.rs)
- [parser.rs](file://codex-rs\execpolicy\src\parser.rs)
- [policy.rs](file://codex-rs\execpolicy\src\policy.rs)
- [decision.rs](file://codex-rs\execpolicy\src\decision.rs)
- [error.rs](file://codex-rs\execpolicy\src\error.rs)
- [execpolicycheck.rs](file://codex-rs\execpolicy\src\execpolicycheck.rs)
- [example.codexpolicy](file://codex-rs\execpolicy\examples\example.codexpolicy)
- [basic.rs](file://codex-rs\execpolicy\tests\basic.rs)
- [README.md](file://codex-rs\execpolicy\README.md)
</cite>

## 目录
1. [简介](#简介)
2. [策略文件结构](#策略文件结构)
3. [规则模型](#规则模型)
4. [解析逻辑](#解析逻辑)
5. [语法示例](#语法示例)
6. [优先级与冲突解决](#优先级与冲突解决)
7. [测试与验证](#测试与验证)
8. [CLI工具](#cli工具)

## 简介
Codex执行策略（execpolicy）语言是一种用于定义命令执行权限的领域特定语言。该语言基于Starlark语法，通过`allow`和`deny`指令的变体（`allow`、`prompt`、`forbidden`）来控制命令的执行行为。策略文件通过前缀匹配机制来识别命令，并支持通配符和条件表达式来实现灵活的匹配规则。

**Section sources**
- [README.md](file://codex-rs\execpolicy\README.md#L1-L55)

## 策略文件结构
策略文件使用Starlark语法，主要由`prefix_rule`函数调用构成。每个规则包含模式匹配、决策和验证示例三个核心部分。文件可以包含多个规则，这些规则按顺序被解析和合并。

```mermaid
flowchart TD
A[策略文件] --> B[解析为AST]
B --> C[构建规则树]
C --> D[存储为MultiMap]
D --> E[按程序名索引]
```

**Diagram sources**
- [parser.rs](file://codex-rs\execpolicy\src\parser.rs#L28-L68)
- [policy.rs](file://codex-rs\execpolicy\src\policy.rs#L17-L32)

**Section sources**
- [parser.rs](file://codex-rs\execpolicy\src\parser.rs#L1-L260)
- [policy.rs](file://codex-rs\execpolicy\src\policy.rs#L1-L136)

## 规则模型
规则模型定义了策略的核心数据结构。`Rule` trait是所有规则的基类型，目前主要实现为`PrefixRule`。规则通过`PatternToken`和`PrefixPattern`来匹配命令前缀。

```mermaid
classDiagram
class Rule {
<<trait>>
+program() string
+matches(cmd) RuleMatch
}
class PrefixRule {
+pattern PrefixPattern
+decision Decision
}
class PrefixPattern {
+first string
+rest PatternToken[]
}
class PatternToken {
<<enum>>
+Single(string)
+Alts(string[])
}
class RuleMatch {
<<enum>>
+PrefixRuleMatch(matchedPrefix, decision)
+HeuristicsRuleMatch(command, decision)
}
Rule <|-- PrefixRule
PrefixRule --> PrefixPattern
PrefixPattern --> PatternToken
PrefixRule --> Decision
Rule --> RuleMatch
```

**Diagram sources**
- [rule.rs](file://codex-rs\execpolicy\src\rule.rs#L11-L153)

**Section sources**
- [rule.rs](file://codex-rs\execpolicy\src\rule.rs#L1-L153)
- [decision.rs](file://codex-rs\execpolicy\src\decision.rs#L7-L28)

## 解析逻辑
策略解析器使用Starlark解析器来处理策略文件。解析过程包括语法分析、语义验证和规则构建三个阶段。解析器通过`PolicyBuilder`来收集和组织规则。

```mermaid
sequenceDiagram
participant Parser as 策略解析器
participant Starlark as Starlark引擎
participant Builder as 策略构建器
participant Policy as 策略对象
Parser->>Starlark : parse(policy_identifier, contents)
Starlark-->>Parser : 返回AST
Parser->>Builder : 初始化PolicyBuilder
Parser->>Starlark : eval_module(ast, globals)
Starlark->>Builder : 调用prefix_rule内置函数
Builder->>Builder : 验证匹配示例
Builder->>Builder : 添加规则到MultiMap
Starlark-->>Parser : 完成评估
Parser->>Policy : build()创建策略对象
Policy-->>Parser : 返回最终策略
```

**Diagram sources**
- [parser.rs](file://codex-rs\execpolicy\src\parser.rs#L28-L260)

**Section sources**
- [parser.rs](file://codex-rs\execpolicy\src\parser.rs#L1-L260)
- [lib.rs](file://codex-rs\execpolicy\src\lib.rs#L1-L21)

## 语法示例
策略语法支持多种匹配模式和验证机制。以下是一些典型的使用示例：

```mermaid
flowchart TD
A[git reset --hard] --> |禁止| B[forbidden]
C[ls, ls -l, ls -a] --> |允许| D[allow]
E[cp foo bar, cp -r src dest] --> |提示| F[prompt]
G[cat file.txt, cat -n README.md] --> |允许| H[allow]
```

**Diagram sources**
- [example.codexpolicy](file://codex-rs\execpolicy\examples\example.codexpolicy#L1-L78)

**Section sources**
- [example.codexpolicy](file://codex-rs\execpolicy\examples\example.codexpolicy#L1-L78)
- [basic.rs](file://codex-rs\execpolicy\tests\basic.rs#L50-L455)

## 优先级与冲突解决
当多个规则匹配同一个命令时，系统采用最严格的决策优先原则。决策的优先级顺序为：`forbidden` > `prompt` > `allow`。这种机制确保了安全策略的严格性。

```mermaid
flowchart LR
A[git status] --> B[匹配git规则]
B --> C[决策: prompt]
A --> D[匹配git status规则]
D --> E[决策: allow]
C --> F[最终决策: prompt]
E --> F
```

**Diagram sources**
- [policy.rs](file://codex-rs\execpolicy\src\policy.rs#L124-L128)

**Section sources**
- [policy.rs](file://codex-rs\execpolicy\src\policy.rs#L1-L136)
- [basic.rs](file://codex-rs\execpolicy\tests\basic.rs#L358-L391)

## 测试与验证
策略文件支持内置的测试和验证机制。通过`match`和`not_match`参数，可以定义正向和负向的测试用例。这些测试在策略加载时自动执行，确保规则的正确性。

```mermaid
flowchart TD
A[定义规则] --> B[指定match示例]
A --> C[指定not_match示例]
B --> D[验证所有match示例匹配]
C --> E[验证所有not_match示例不匹配]
D --> F[规则验证成功]
E --> F
D --> G[发现未匹配示例]
E --> H[发现意外匹配]
G --> I[验证失败]
H --> I
```

**Diagram sources**
- [rule.rs](file://codex-rs\execpolicy\src\rule.rs#L112-L152)

**Section sources**
- [rule.rs](file://codex-rs\execpolicy\src\rule.rs#L112-L152)
- [basic.rs](file://codex-rs\execpolicy\tests\basic.rs#L314-L354)

## CLI工具
Codex提供了一个命令行工具来测试和验证策略文件。该工具可以加载一个或多个策略文件，并对指定命令进行评估，输出JSON格式的评估结果。

```mermaid
sequenceDiagram
participant User as 用户
participant CLI as codex execpolicy
participant Parser as 策略解析器
participant Policy as 策略对象
participant Output as JSON输出
User->>CLI : codex execpolicy check --rules policy.rules git status
CLI->>Parser : 加载策略文件
Parser->>Policy : 构建策略对象
CLI->>Policy : check(git status)
Policy->>Policy : 查找匹配规则
Policy-->>CLI : 返回评估结果
CLI->>Output : 格式化为JSON
Output-->>User : 输出结果
```

**Diagram sources**
- [execpolicycheck.rs](file://codex-rs\execpolicy\src\execpolicycheck.rs#L1-L84)
- [main.rs](file://codex-rs\execpolicy\src\main.rs#L1-L19)

**Section sources**
- [execpolicycheck.rs](file://codex-rs\execpolicy\src\execpolicycheck.rs#L1-L84)
- [main.rs](file://codex-rs\execpolicy\src\main.rs#L1-L19)
- [README.md](file://codex-rs\execpolicy\README.md#L22-L35)